=============

>> dealing with files: open file and read (low level api not recommended, use for properties/schemas), pandas, pyspark
>> lambda, list comprehension, filter, map/set, sorted

>> get column names(metadata) from schemas.json
import json
file_path = 'data/retail_db/schemas.json'
schemas = json.load(open(file_path))

def get_column_names(schemas, ds_name, sorting_key='column_position'):
    column_details = schemas[ds_name]
    columns = sorted(column_details, key=lambda col: col[sorting_key])
    return [col['column_name'] for col in columns]

>> read data and process using python - not recommend these low level apis
orders_file = open('data/retail_db/orders/part-00000', 'r')
orders_str = orders_file.read()
orders = orders_str.splitlines()
list(filter(lambda order: order.split(',')[3] == 'COMPLETE', orders))
list(filter(lambda order: order.split(',')[3] in ('COMPLETE', 'CLOSED'), orders))
list(map(lambda order: order.split(',')[3], orders))
set(map(lambda order: order.split(',')[3], orders))
sorted(orders, key=lambda order: int(order.split(',')[2]))

>> read data and process using python pandas -  recommend for small/medium datasets




=======================

class: is design - has attributes, methods
object: instance from class
self: referring to the objects
init - special method - to initialize variables - called init mtd automatically when you instantiate object (we can say construcor)

========================

variables: instance variable (within init mtd), class variable
mtd: instance mtd, class mtd, static mtd

class Student:
    college = 'narayana'  # class variable
    def __init__(self, m1, m2): # instance variable
        self.m1 = m1
        self.m2 = m2
    def avg(self):   # instance method
        return (self.m1 + self.m2)/2
    @classmethod   
    def get_school(cls):   # class method
        return cls.college
    @staticmethod    # static method
    def fact():
        print('this returns factorial of number')


s1 = Student(20, 40)
print(s1.college)
print(Student.college)
print(s1.m1)
print(s1.avg())
print(s1.get_school())
s1.fact()

===================

logging: avoid print - its just for testing - not recommended in prod to display these garbage values
helps in debugging, disable/enable logging easily

import logging

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
f = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
fh = logging.FileHandler('debug.log')
fh.setFormatter(f)
logger.addHandler(fh)

# logging.basicConfig(filename='debug.log', filemode='w', level=logging.INFO, 
# format='%(asctime)s - %(levelname)s - %(message)s')

# logging.disable()
# levels - DEBUG, INFO, WARNING, ERROR, CRITICAL

logger.debug('this is debug')
logger.info('this is info')
logger.warning('this is warning')
logger.error('this is error')
logger.critical('this is critical')

# logging.error('this name is not valid')

=======================

>>  configparser is a Python module that provides functionality for handling configuration files, similar to .ini files. 

>> These files typically contain sections, each with key-value pairs.
[Section1]
key1 = value1
key2 = value2

>> 
import configparser
# Create the config parser object
config = configparser.ConfigParser()
# Read from the config file
config.read(path+'config.ini')
# Access a value
config.get('Section1', 'key2')

=====================

In Python, the uuid module provides functions to generate universally unique identifiers (UUIDs). 

=======================


