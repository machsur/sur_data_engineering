=============

-- dealing with files: open file and read (low level api not recommended, use for properties/schemas), pandas, pyspark
-- python collects (list, tuple, set, dict) - used for dealing with metadata (mostly list, dict) - for data processing we use pandas/spark
-- Python Collections:
list - Group of similar or homogenous elements. Need not be unique.
tuple - Group of elements of different types.
set - Group of similar and unique elements.
dict - Group of key value pairs where keys are unique.
we see list and dict more often from the perspective of Data Engineering.


------------------
orders_file = open('data/retail_db/orders/part-00000', 'r')
orders_str = orders_file.read()
orders = orders_str.splitlines()


=======================

class: is design - has attributes, methods
object: instance from class
self: referring to the objects
init - special method - to initialize variables - called init mtd automatically when you instantiate object (we can say construcor)

========================

variables: instance variable (within init mtd), class variable
mtd: instance mtd, class mtd, static mtd

class Student:
    college = 'narayana'  # class variable
    def __init__(self, m1, m2): # instance variable
        self.m1 = m1
        self.m2 = m2
    def avg(self):   # instance method
        return (self.m1 + self.m2)/2
    @classmethod   
    def get_school(cls):   # class method
        return cls.college
    @staticmethod    # static method
    def fact():
        print('this returns factorial of number')


s1 = Student(20, 40)
print(s1.college)
print(Student.college)
print(s1.m1)
print(s1.avg())
print(s1.get_school())
s1.fact()

===================

logging: avoid print - its just for testing - not recommended in prod to display these garbage values
helps in debugging, disable/enable logging easily

import logging

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
f = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
fh = logging.FileHandler('debug.log')
fh.setFormatter(f)
logger.addHandler(fh)

# logging.basicConfig(filename='debug.log', filemode='w', level=logging.INFO, 
# format='%(asctime)s - %(levelname)s - %(message)s')

# logging.disable()
# levels - DEBUG, INFO, WARNING, ERROR, CRITICAL

logger.debug('this is debug')
logger.info('this is info')
logger.warning('this is warning')
logger.error('this is error')
logger.critical('this is critical')

# logging.error('this name is not valid')

=======================

>>  configparser is a Python module that provides functionality for handling configuration files, similar to .ini files. 

>> These files typically contain sections, each with key-value pairs.
[Section1]
key1 = value1
key2 = value2

>> 
import configparser
# Create the config parser object
config = configparser.ConfigParser()
# Read from the config file
config.read(path+'config.ini')
# Access a value
config.get('Section1', 'key2')

=====================

In Python, the uuid module provides functions to generate universally unique identifiers (UUIDs). 

=======================


