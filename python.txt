=======================

class: is design - has attributes, methods
object: instance from class
self: referring to the objects
init - special method - to initialize variables - called init mtd automatically when you instantiate object (we can say construcor)

========================

variables: instance variable (within init mtd), class variable
mtd: instance mtd, class mtd, static mtd

class Student:
    college = 'narayana'  # class variable
    def __init__(self, m1, m2): # instance variable
        self.m1 = m1
        self.m2 = m2
    def avg(self):   # instance method
        return (self.m1 + self.m2)/2
    @classmethod   
    def get_school(cls):   # class method
        return cls.college
    @staticmethod    # static method
    def fact():
        print('this returns factorial of number')


s1 = Student(20, 40)
print(s1.college)
print(Student.college)
print(s1.m1)
print(s1.avg())
print(s1.get_school())
s1.fact()

===================

logging: avoid print - its just for testing - not recommended in prod to display these garbage values
helps in debugging, disable/enable logging easily

import logging

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
f = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
fh = logging.FileHandler('debug.log')
fh.setFormatter(f)
logger.addHandler(fh)

# logging.basicConfig(filename='debug.log', filemode='w', level=logging.INFO, 
# format='%(asctime)s - %(levelname)s - %(message)s')

# logging.disable()
# levels - DEBUG, INFO, WARNING, ERROR, CRITICAL

logger.debug('this is debug')
logger.info('this is info')
logger.warning('this is warning')
logger.error('this is error')
logger.critical('this is critical')

# logging.error('this name is not valid')
