============================================================================================================================================================
Python:
>> Interpreter: The programme that runs your code.
   Virtual Environment: A separate "workspace" that uses a Python interpreter but has its own packages and dependencies.
>> pip - tool for install python packages
   pypi - centralized repository for py packages
>> terminate the python programme  ---> sys.exit()
   execute the file using the specified program or interpreter (#!/usr/bin/python3.5)
>> Datatypes:
>> operators:
	arthematic: +  -  /  *  **  %  //
	comparision:   ==   !=  >   >=   <    <=
	logical: and or not
	identify:   x is y    x is not y
	membership:  x in y   x not in y
>> Hiding Passwords and Secret Keys in Environment Variables (linux/mac/Windows) and access them into code -------> os.environ.get("key")
	export SECRET_KEY="my$ecretP@ssw0rd" for linux  | set SECRET_KEY="my$ecretP@ssw0rd"  for windows
	secret_key = os.environ.get("SECRET_KEY")
>> Config Files usage in python
	import configparser
	config = configparser.ConfigParser()   # Create a parser
	config.read('config.ini')  # Read the config file
	db_host = config['database']['host']   |   db_port = config.getint('database', 'port')  # Access values
>> Handlling errors: using the try-except block --> catch and respond to errors gracefully, instead of crashing.
	any error in the try block, exception will be raised and it caught by except block

	compile time error: Syntatical --- print("Hello World"  # Missing closing parenthesis 
	Logical error: wrong output --- print("Sum is:", a * b)  # Wrong logic: used * instead of +
	run time error:  occur while the program is running --- print(5 / 0)  # Division by zero
>>  
Statement	Purpose				Common Use Case
break		Exit the loop entirely		Stop when a condition is met
continue	Skip to the next iteration	Skip unwanted values
pass		Do nothing (placeholder)	Placeholder for future code
>> 
    functions: reuse block of code / 
    	positional / keyworded / variable length: def sum(a, *b): / keyword variable length: def person(name, **data)
    	Global variable (outside fun) / local variable (inside fun)
    recursion: function calling it self ex: factorial
    anonymous function, short, one-line function: x = lambda a: a * a / print(x(5))
    	filter: list(filter(lambda a: a%2 == 0, lt))
    	map: list(map(lambda a: a * 2, lt))
    	reduce: from functools import reduce / sum = reduce(lambda a, b: a + b, lt)
>> List comprehensation: create new list from existiong list or other iterals
	filtered_ls = [i for i in ls if i%2 == 0 & i > 2]
>> 
Feature		List			Array (array)		NumPy Array		Pandas DataFrame
Data Type	Mixed			Homogeneous		Homogeneous		Mixed (tabular)
Speed		Slow			Faster than list	Very fast		Fast (for tabular ops)
Use Case	General use		Numeric data		Scientific calc		Data analysis
Import Needed	No			Yes			Yes			Yes
    
Excel - Can not handle large sets of data
Python - Need to write code to find answers
Pandas dataframe: its python modules - makes data scientist life easier and effective

>> library (group of packages) --> Package (folder - collection of modules) ---> module (file1.py, file2.py, __init__.py ) : help organize and reuse of code
 	math, random, array, os, shutil, json, csv, datetime, time, re, request, uuid

1. create folder structure
folder
|
my_package/
├── __init__.py       # Marks this as a package
├── utils.py          # Contains a sample function
setup.py              # Metadata and build instructions
README.md             # Basic documentation

# setup.py file
from setuptools import setup, find_packages
setup(
    name='my_package',
    version='0.1',
    packages=find_packages(),
    install_requires=[],  # Add dependencies here
    author='Your Name',
    description='A custom Python package',
)
2. python setup.py bdist_wheel  --> This will generate a .whl file inside the dist/ directory.
3. activate venv
4. Navigate to the directory: pip install dist/my_package-0.1-py3-none-any.whl     /     pip install . (step 2 not required)

>> Why Use Logging Instead of Print?
Levels: You can categorize messages (DEBUG, INFO, WARNING, ERROR, CRITICAL).
Output Options: Log to files, streams, or external systems.
Configurability: Control format, level, and destination of logs.
Production-Ready: Logging is more suitable for real-world applications than print().

import logging
# Configure the logger
logging.basicConfig(
    level=logging.DEBUG,  # Set the minimum level of log messages: info, warning, error, critical
    format='%(asctime)s - %(levelname)s - %(message)s',  # Log message format
    filename='app.log',  # Log file name
    filemode='w'  # Overwrite the log file each time the script runs
)
logging.debug("This is a debug message")
2025-05-30 12:10:31,123 - DEBUG - This is a debug message

def bq_logger(path, name):
	logger = logging.getLogger(name)
	logger.setLevel(logging.INFO)
	fomatter = logging.Formater(' ')
	handler = logging.FileHandler(os.path.join(path, name), 'w')
	handler.setFormatter(formatter)
	looger.addHandler(handler)
	return logger

>> 
OOPS: Class, object, constructer, 
inheritance: parent class, child class

--polymorphisum: 
	typically achived using method overriding and interfaces(AbstractBaseClass)
	provides way to perform a single action in different forms.
method overriding: allows child class to implement specific method that is already defined in parent class.

-- Encaptulation: 
	public variable: can access outside class
	private variable: cannt acces from outside of class
	protected variable: can access from derived class, other not


	


=================================================================================================================================

Q&A

>> find student details corresponding to max_marks:    student = [('suresh', 'ong', 85), ('seshu', 'bng', 74), ('naven', 'kk', 40)]
>> Given an array, find the minimum and maximum values:    ans. builtin mtds, sorting, python code
>> Given a string, count the char occurrences of word in a dictionary:    Input: 'aaabbbccddeeeee'
>> Count Vowels from Given words .
>> find line_count, words, chars in the files
>> Write a Python script to count the frequency of characters/words in a text file.  --------> using for loop /from collections import Counter
>> Reversing a String using an Extended Slicing techniques. -------> builtin / slicing / code
>> Find the highest occurrences of each word from string and sort them in order.
>> Remove Duplicates from List. set / for loop / list comprehension 
>> Sort a List without using Sort keyword. built-in / bubble sort /
>> Find the pair of numbers in this list whose sum is n no.
>> Read and print values from an Excel file using Pandas.
>> Handle file exceptions (missing or corrupted Excel files) gracefully. no error in try block --> try - else - finally /// error ---> except - finally
>> Calculate the Intersection of Two Lists without using Built-in Functions:      print(set(ls1) & set(ls2)) or lss =[item for item in ls1 if item in ls2]
>> What is a docstring in Python?  Docstrings are enclosed in triple quotes (""" or ''') and can span multiple lines.
>> What is pass in Python? When is it used? --> Placeholder for future class/function / It does nothing when executed 
>> Which data structure occupies more memory: list or tuple? Why?
	lists generally occupy more memory than tuples. --> their size and contents can change, more methods
	print(sys.getsizeof(list_obj))   # e.g., 120 bytes
>>  Given a list [2, 3, 4, 5, 6], how can you sum all elements? (Discuss available functions)
>>  What is a constructor in Python and its purpose?
	It is special method (__init__) and automatically called to initilize variables when a new instance of a class is created.




===============================================================================================================


