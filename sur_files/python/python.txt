============================================================================================================================================================
>> BigO
	time complexity: code1 - 15 sec < code2-60sec, means code1 is better than code2 / different machine time varies / so, we measure in terms of no of operations
	Space complexity: code1 15sec but larger space and code2 60sec lesser space, here code2 is better if we concern about space.

>> omega (best case), theta (avg case), omecron (bigO-worst case)	
	O(1) - const oper even n varies
	O(logn) - 2^3 = 8 / log8=3 / divide two parts
	O(n) - for loop
	O(nlogn) - some sorting algortiums
	O(n2) - nested for loop
	for different inputs - O(a+b) - O(a*b)

>> 
============================================================================================================================================================================
Python:
>> Interpreter: The programme that runs your code.
   Virtual Environment: A separate "workspace" that uses a Python interpreter but has its own packages and dependencies.
>> pip - tool for install python packages
   pypi - centralized repository for py packages
>> terminate the python programme  ---> sys.exit()
   execute the file using the specified program or interpreter (#!/usr/bin/python3.5)
>> Datatypes:
>> operators:
	arthematic: +  -  /  *  **  %  //
	comparision:   ==   !=  >   >=   <    <=
	logical: and or not
	identify:   x is y    x is not y
	membership:  x in y   x not in y
>> Hiding Passwords and Secret Keys in Environment Variables (linux/mac/Windows) and access them into code -------> os.environ.get("key")
	export SECRET_KEY="my$ecretP@ssw0rd" for linux  | set SECRET_KEY="my$ecretP@ssw0rd"  for windows
	secret_key = os.environ.get("SECRET_KEY")
>> Config Files usage in python
	import configparser
	config = configparser.ConfigParser()   # Create a parser
	config.read('config.ini')  # Read the config file
	db_host = config['database']['host']   |   db_port = config.getint('database', 'port')  # Access values

>> Handlling errors: using the try-except block --> catch and respond to errors gracefully, instead of crashing.
	any error in the try block, exception will be raised and it caught by except block
	compile time error: Syntatical --- print("Hello World"  # Missing closing parenthesis 
	Logical error: wrong output --- print("Sum is:", a * b)  # Wrong logic: used * instead of +
	run time error:  occur while the program is running --- print(5 / 0)  # Division by zero

>>  
Statement	Purpose				Common Use Case
break		Exit the loop entirely		Stop when a condition is met
continue	Skip to the next iteration	Skip unwanted values
pass		Do nothing (placeholder)	Placeholder for future code

>> 
-- functions: reuse block of code 
	positional / keyworded / variable length: def sum(a, *b): / keyword variable length: def person(name, **data)
	Global variable (outside fun) / local variable (inside fun)  
-- recursion: function calling it self ex: factorial
-- anonymous function, short, one-line function: 
	x = lambda a: a * a / print(x(5))
	filter: list(filter(lambda a: a%2 == 0, lt))   --> ananous fun, reg function, in-built fun
	map: list(map(lambda a: a * 2, lt))
	reduce: from functools import reduce / sum = reduce(lambda a, b: a + b, lt)

>> List comprehensation: create new list from existiong list or other iterals
nls = [i for i in ls if i%2==0]   /  	nls1=list(filter(lambda x: x%2==0, ls))
lsd = {name:dept for name, dept in list_of_tuples}  
lss = {i for i in ls}

>> 	ordered		mutable		duplicates
list[]	Y		Y		Y
tuple() Y		N		Y
set{}	N		Y		N
dict{}	Y		Y		N - based on key

>> 
Feature		List			Array (array)		NumPy Array		Pandas DataFrame
Data Type	Mixed			Homogeneous		Homogeneous		Mixed (tabular)
Speed		Slow			Faster than list	Very fast		Fast (for tabular ops)
Use Case	General use		Numeric data		Scientific calc		Data analysis
Import Needed	No			Yes			Yes			Yes  
Pandas dataframe: its python modules - makes data scientist life easier and effective (Python - Need to write code, Excel - Can not handle large data)

>> library (group of packages) --> Package (folder - collection of modules) ---> module (file1.py, file2.py, __init__.py ) : help organize and reuse of code
 	math, random, array, os, shutil, json, csv, datetime, time, re, request, uuid

1. create folder structure
folder
|
my_package/
├── __init__.py       # Marks this as a package
├── utils.py          # Contains a sample function
setup.py              # Metadata and build instructions
README.md             # Basic documentation

# setup.py file
from setuptools import setup, find_packages
setup(
    name='my_package',
    version='0.1',
    packages=find_packages(),
    install_requires=[],  # Add dependencies here
    author='Your Name',
    description='A custom Python package',
)
2. python setup.py bdist_wheel  --> This will generate a .whl file inside the dist/ directory.
3. activate venv
4. Navigate to the directory: pip install dist/my_package-0.1-py3-none-any.whl     /     pip install . (step 2 not required)

>> Why Use Logging Instead of Print?
Levels: You can categorize messages (DEBUG, INFO, WARNING, ERROR, CRITICAL).
Output Options: Log to files, streams, or external systems.
Configurability: Control format, level, and destination of logs.
Production-Ready: Logging is more suitable for real-world applications than print().

import logging
# Configure the logger
logging.basicConfig(
    level=logging.DEBUG,  # Set the minimum level of log messages: info, warning, error, critical
    format='%(asctime)s - %(levelname)s - %(message)s',  # Log message format
    filename='app.log',  # Log file name
    filemode='w'  # Overwrite the log file each time the script runs
)
logging.debug("This is a debug message")
2025-05-30 12:10:31,123 - DEBUG - This is a debug message

def bq_logger(path, name):
	logger = logging.getLogger(name)
	logger.setLevel(logging.INFO)
	fomatter = logging.Formater(' ')
	handler = logging.FileHandler(os.path.join(path, name), 'w')
	handler.setFormatter(formatter)
	looger.addHandler(handler)
	return logger

>> file operations:

>> 
OOPS: Class, object, constructer, 
inheritance: parent class, child class

--polymorphisum: 
  Duck typing: class: ide.execute() | 
  method overloading: two same methods in calss but takes diff params - not available in python (can achive by a=None & if condi)
  method overriding: child class method overrides parent class mtd - ex. my phone overrides my dad phone.

-- Encaptulation: 
	public variable: can access outside class
	private variable: cannt acces from outside of class
	protected variable: can access from derived class, other not
-- Abstraction

-- Magic/Tunder/double underscore methods: enable you to define the behavour of objects for built-in operations such as arth ope, comp oper, more



	


=================================================================================================================================


